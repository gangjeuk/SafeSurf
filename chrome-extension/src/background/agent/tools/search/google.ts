import { StructuredTool } from '@langchain/core/tools';
import * as cheerio from 'cheerio';
import { z } from 'zod';
import type { CallbackManagerForToolRun } from '@langchain/core/callbacks/manager';
import type { ToolParams } from '@langchain/core/tools';
import type { InferInteropZodOutput } from '@langchain/core/utils/types';

export type SearchDepth = 'basic' | 'advanced';
export type TopicType = 'general' | 'news' | 'finance';
/**
 * A single search result from the Google Search API.
 */
export type SearchResult = {
  /**
   * The title of the search result.
   */
  title: string;
  /**
   * The URL of the search result.
   */
  url: string;
  /**
   * A short description of the search result.
   */
  content: string;
  /**
   * Publisher of content
   */
  publisher?: string;
  /**
   * The relevance score of the search result.
   */
  score: number;
  /**
   * The cleaned and parsed HTML content of the search result. Only if
   * {@link SearchParams.includeRawContent} is true.
   */
  raw_content: string | null;
} & Record<string, unknown>;

/**
 * The base response from the Google Search API.
 */
export type BaseSearchResponse = {
  /**
   * The search query that was executed.
   */
  query: string;
  /**
   * A short answer to the user's query, generated by an LLM. Included in the response only if
   * {@link SearchParams.include_answer} is requested (i.e., set to `true`, `"basic"`, or
   * `"advanced"`).
   */
  answer?: string;
  /**
   * The results from the search.
   */
  results: SearchResult[];
  /**
   * The response time of the search.
   */
  response_time: number;
} & Record<string, unknown>;

/**
 * Options for the SearchResults tool.
 */
export type SearchAPIRetrieverFields = ToolParams & {
  /**
   * The base URL to be used for the Google Search API.
   *
   * @default "https://google.com/search"
   */
  apiBaseUrl?: string;

  /**
   * The maximum number of search results to return.
   *
   * @default 5
   */
  maxResults?: number;

  /**
   * Include a short answer to the original query.
   *
   * @default false
   */
  includeAnswer?: boolean;

  /**
   * Include the cleaned and parsed HTML content of each search result.
   * "markdown" returns search result content in markdown format.
   * "text" returns the plain text from the results and may increase latency.
   * If true, defaults to "markdown"
   *
   * @default false
   */
  includeRawContent?: boolean | 'markdown' | 'text';

  /**
   * A list of keywords to specifically include in the search results.
   *
   * @default []
   */
  includeKeywords?: string[];

  /**
   * A list of keywords to specifically exclude from the search results.
   *
   * @default []
   */
  excludeKeywords?: string[];

  /**
   * The depth of the search. It can be "basic" or "advanced".
   *
   * @default "basic"
   */
  searchDepth?: SearchDepth;

  /**
   * The name of the tool.
   *
   * @default "google_search"
   */
  name?: string;

  /**
   * The description of the tool.
   *
   * @default "A search engine optimized for comprehensive, accurate, and trusted results. Useful for when you need to answer questions about current events. Input should be a search query."
   */
  description?: string;
  /**
   * Whether to return the tool's output directly.
   *
   * Setting this to true means that after the tool is called,
   * an agent should stop looping.
   *
   * @default false
   */
  returnDirect?: boolean;

  /**
   * An API wrapper that can be used to interact with the data fetching. Useful when setting custom fetching logic, such as rate limiting.
   *
   * If specified, the tool will use this API wrapper instead of default `fetch`
   */
  apiWrapper?: typeof fetch;

  /**
   * The number of content chunks to retrieve from each source. Each chunk's length is maximum 500 characters. Available only when searchDepth is advanced.
   *
   * @default 3
   */
  chunksPerSource?: number;

  /**
   * The category of the search. This will determine which of our agents will be used for the search. Currently, only "general" and "news" are supported.
   *
   * @default "general"
   */
  topic?: TopicType;
};

function _generateSuggestions(params: Record<string, unknown>): string[] {
  const suggestions: string[] = [];

  const { includeKeywords, excludeKeywords, searchDepth } = params;

  if (includeKeywords && Array.isArray(includeKeywords) && includeKeywords.length > 0) {
    suggestions.push('Remove include_domains argument');
  }
  if (excludeKeywords && Array.isArray(excludeKeywords) && excludeKeywords.length > 0) {
    suggestions.push('Remove exclude_domains argument');
  }
  if (searchDepth === 'basic') {
    suggestions.push("Try a more detailed search using 'advanced' search_depth");
  }

  return suggestions;
}

const inputSchema = z.object({
  query: z.string().describe('Search query to look up'),
  includeKeywords: z
    .array(z.string())
    .optional()
    .describe(
      `A list of keywords to restrict search results to.

Use this parameter when:
1. The user explicitly requests information from specific websites (e.g., "Find climate data from nasa.gov")
2. The user mentions an organization or company without specifying the domain (e.g., "Find information about iPhones from Apple")

In both cases, you should determine the appropriate keywords (e.g., ["nasa"] or ["apple"]) and set this parameter.

Results will ONLY come from the specified keywords - no other sources will be included.
Default is None (no domain restriction).`,
    ),
  excludeKeywords: z
    .array(z.string())
    .optional()
    .describe(
      `A list of keywords to exclude from search results.

Use this parameter when:
1. The user explicitly requests to avoid certain websites (e.g., "Find information about climate change but not from twitter.com")
2. The user mentions not wanting results from specific organizations without naming the domain (e.g., "Find phone reviews but nothing from Apple")

In both cases, you should determine the appropriate keywords to exclude (e.g., ["twitter"] or ["apple"]) and set this parameter.

Results will filter out all content from the specified keywords.
Default is None (no domain exclusion).`,
    ),
  searchDepth: z
    .enum(['basic', 'advanced'])
    .optional()
    .describe(
      `Controls search thoroughness and result comprehensiveness.

Use "basic" (default) for simple queries requiring quick, straightforward answers.

Use "advanced" for complex queries, specialized topics, 
rare information, or when in-depth analysis is needed.`,
    ),
});

/**
 * A Tool for performing searches
 * the results. Extends the StructuredTool class. It includes optional
 * parameters for refining search results, such as specifying keywords,
 * and search depth.
 *
 * Example:
 * ```typescript
 * const tool = new GoogleSearch({
 *   maxResults: 3,
 * });
 * const results = await tool.invoke({ query: "latest AI news" });
 * console.log(results);
 * ```
 */
export class GoogleSearch extends StructuredTool<typeof inputSchema, BaseSearchResponse> {
  static lc_name(): string {
    return 'GoogleSearch';
  }

  override description: string =
    'A search engine optimized for comprehensive, accurate, and trusted ' +
    'results. Useful for when you need to answer questions about current ' +
    'events. Input should be a search query.';

  override name: string = 'google_search';

  override schema = inputSchema;

  apiBaseUrl = 'https://google.com/search';

  maxResults?: number;

  includeAnswer?: boolean;

  includeRawContent?: boolean | 'markdown' | 'text';

  includeKeywords?: string[];

  excludeKeywords?: string[];

  searchDepth?: SearchDepth;

  chunksPerSource?: number;

  /**
   * Constructs a new instance of the GoogleSearch tool.
   * @param params Optional configuration parameters for the tool.
   *               Includes options like `maxResults`,
   *               `includeAnswer`, `searchDepth`, etc.
   *               See {@link SearchAPIRetrieverFields} for details.
   */
  constructor(params: SearchAPIRetrieverFields = {}) {
    super(params);

    if (params.name) {
      this.name = params.name;
    }

    if (params.description) {
      this.description = params.description;
    }

    this.includeKeywords = params.includeKeywords;
    this.excludeKeywords = params.excludeKeywords;
    this.searchDepth = params.searchDepth;
    this.maxResults = params.maxResults;
    this.includeAnswer = params.includeAnswer;
    this.includeRawContent = params.includeRawContent;
    this.chunksPerSource = params.chunksPerSource;
  }

  async _call(
    input: InferInteropZodOutput<typeof inputSchema>,
    _runManager?: CallbackManagerForToolRun,
  ): Promise<BaseSearchResponse | { error: string }> {
    try {
      const { query, includeKeywords, excludeKeywords } = input;

      const includeKeyword = includeKeywords?.map(k => `"${k}"`).join(' ') ?? '';
      const excludeKeyword = excludeKeywords?.map(k => `-${k}`).join(' ') ?? '';

      const structedQuery = `${query} ${includeKeyword} ${excludeKeyword}`;
      console.log(structedQuery);
      const html = await (await fetch(`${this.apiBaseUrl}?q=${structedQuery}`)).text();
      console.log(structedQuery, html);

      const page = cheerio.load(html);

      const urlNodes = page('.A6K0A');
      const youtubeNodes = page('.LLtSOc');
      const searchRet: SearchResult[] = [];
      for (let i = 0; i < urlNodes.length; i++) {
        const node = cheerio.load(urlNodes[i]);
        try {
          const srcName = node('.VuuXrf').text();

          const url = node('.zReHs').attr('href');

          const title = node('.LC20lb').text();
          const content = node('.VwiC3b').text().replaceAll('...', '.');

          if (srcName && url && title && content) {
            searchRet.push({ srcName, url, title, content, score: -1, raw_content: null });
          }
        } catch (_) {
          // pass
        }
      }

      for (let i = 0; i < youtubeNodes.length; i++) {
        const node = cheerio.load(youtubeNodes[i]);
        try {
          const srcName = node('.R8BTeb').text();
          const url = node('.KEVENd').attr('href');
          const title = node('.R8W6DUrcBTeb').text();
          const content = node('.gxZfx').text().replaceAll('...', '.');
          if (srcName && url && title && content) {
            searchRet.push({ srcName, url, title, content, score: -1, raw_content: null });
          }
        } catch (_) {
          // pass
        }
      }

      return { query: structedQuery, results: searchRet, response_time: 0 };
    } catch (e: unknown) {
      const errorMessage = e && typeof e === 'object' && 'message' in e ? e.message : String(e);
      return { error: errorMessage as string };
    }
  }
}
